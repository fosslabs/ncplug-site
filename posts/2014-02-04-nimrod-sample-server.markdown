---
title: Простой файловый сервер на языке Nimrod
author: Александр Чичигин
tags: nimrod
---

Возможно, интересующиеся всякими маргинальными языками программирования недавно
узнали про [Nimrod](http://nimrod-lang.org/) благодаря [презентации на InfoQ](http://www.infoq.com/presentations/nimrod).
Хотя на самом деле этот язык развивается уже 10 лет, и за это время его
не только не бросили, но и очень достойно взрастили, несмотря на отсутствие
широкой рекламы и нагнетания ажиотажа.

Все главные черты Nimrod как языка и рантайма перечислены на главной странице,
но я всё же повторю приковавшие больше всего внимания.

Во-первых, синтаксис языка напоминает гибрид Pascal и Python, но при всей дикости
такого сочитания, в работе отвращения не вызывает. Мне показался скорее забавным.

Во-вторых, компилятор производит source-to-source трансляцию в C (или JavaScript ---
не очень понятно зачем, по-видимому, мода сказалась), выполняя ряд оптимизаций,
в частности, dead code elimination. После чего процесс производства бинарника
завершает компилятор C --- можно использовать GCC или Clang. При большом желании
можно получить бинарник практически без рантайма, без GC и без зависимостей от
системных библиотек, пригодный для запуска на микроконтроллерах.

В-третьих, про GC и потоки. В Nimrod каждому потоку выделяется собственная куча
(как в Erlang), и потоки не могут обращаться к объектам в чужой куче --- при
передаче данных по каналам используется копирование (опять как в Erlang).
Таким образом, GC может выделять и освобождать память разных потоков независимо
и одновременно. Ещё обещают soft real-time, хотя под этим могут подразумевать
именно независимую сборку мусора. В принципе, в стандартной библиотеке Nimrod
есть поддержка (локальной) модели акторов поверх потоков и каналов, но эта
функциональность ещё не готова к промышленному использованию. К тому же, потоки
сравнительно "тяжёлые" и я не понял каким образом они отображаются на потоки ОС
(скорее всего --- 1:1).

В-четвёртых, в Nimrod реализовано аж три системы макросов: templates, macros и
term rewriting system. Первая предлагает простые макросы, основанные на квазицитировании,
вторая позволяет руками сделать с AST всё, что заблагорассудится, а третья мощна
настолько, что я даже взглянуть побоялся. :)

Помимо этого есть простой FFI для использования C-библиотек и утилита для конвертации
заголовочных файлов (благодаря чему у Nimrod имеется много полезных байндингов).
Присутствует разделение указателей на garbage collected (ref) и plain (ptr) для
работы с теми самыми низкоуровневыми библиотеками. Поддерживается упрощённая
модель объектно-ориентированного программирования с помощью мультиметодов и
сокрытия лишнего в недрах модулей.

В общем, после знакомства с Nimrod, стало неясно зачем Google взялся разрабатывать
свой Go, а Mozilla --- свой Rust... :)

Если же вам интересно, как на таком языке выглядит простенький сервер, показывающий
содержимое каталогов и раздающий файлы, прошу читать далее...

<!--more-->

Чтобы программировать на Nimrod прежде всего нужен компилятор. Каноническим
(единственным?) способом получения компилятора является сборка из исходников.
Этот несложный процесс описан в [getting started guide](https://github.com/Araq/Nimrod/wiki/Getting-Started).
Видимо, благодаря трансляции в C сам Nimrod получился столь же переносимым ---
без проблем собрался у меня на Raspberry Pi.

<div class="info">
<div>**Ремарка**. Почему Raspberry Pi?</div>
Собственно, если бы не она --- не было бы и поста. :) <br/>
Поскольку по современным меркам ресурсы Raspberry Pi довольно скромны, возникает
желание, а то и необходимость, программировать на чём-то более производительном,
чем интерпретируемые языки (и использовать нативные библиотеки). Но программировать
на неприкрытом C/C++ довольно неуютно, а Haskell отпадает, т.к. GHC на ARM собрать
весьма проблематично. Go поддерживает эту платформу постольку поскольку, так что
остаются только D, Rust и Nimrod. Не являясь фанатом фигурных скобок и точек с запятой,
решил дать шанс третьему кандидату. :)
</div>

Если вы прошли getting started guide до конца, то кроме компилятора Nimrod
обзавелись и менеджером библиотек babel (аналог cabal или npm --- заметьте,
не каждый язык может таким похвастаться). Тогда у нас есть возможность смухлевать:

```
babel jester
```

Эта команда установит sinatra-подобный REST framework Jester, использующийся,
например, в движке форума Nimrod (написанного на Nimrod, как можно догадаться).
Им мы и воспользуемся для создания нашего незамысловатого сервера.

Вообще, оказалось что компилятор Nimrod знает про Babel и умеет использовать
установленные им библиотеки самостоятельно, так что необязательно пользоваться
последним, когда разрабатывается конечное приложение. Тем не менее, я создал
файл `fserver.babel` с таким содержимым:

```
[Package]
name          = "fserver"
version       = "0.1.0"
author        = "Alexander Tchitchigin"
description   = "Simple file server."
license       = "BSD"

bin = "fserver"

[Deps]
Requires: "nimrod >= 0.9.3, jester >= 0.1.0"
```
и собирал проект командой
```
babel build
```

Сервер же полностью поместился в файл `fserver.nim`:
``` nimrod
import os, jester, htmlgen, mimetypes

const
    CURRENT = "."

let
    mimes = newMimetypes()


proc extractMimetype(path: string): string =
    let ext = splitFile(path).ext.substr(1) # without leading "."
    echo(ext)
    return getMimetype(mimes, ext)

proc handleFile(path: string): string = readFile(path)

proc handleDir(path: string): string =
    result = h1(path & ":")
    result.add "<ul>"
    for kind, p in walkDir(path):
        let
            name = SplitPath(p).tail
        result.add li(a(href=p, name))
    result.add "</ul>"

getRe regex"/(.*)$":
    let path = request.matches[0]
    if path == "":
        resp handleDir(CURRENT)
    else:
        if existsDir(path):
            resp handleDir(path)
        elif existsFile(path):
            headers = {"Content-Type": extractMimetype(path)}.newStringTable()
            body = handleFile(path)
        else:
            status = Http404

run()
```

Поскольку сервер предназначен для раздачи файлов из текущей директории или поддиректорий,
определяется единственное правило роутинга, которое обрабатывает все пути. Если
путь соответствует директории, мы генерируем и отдаём HTML-страницу со списком
всех файлов и директорий в ней, если файлу --- определяем его Mimetype и отдаём
этот файл. Для простоты файл считывается как строка в память.

Для определения Mimetype файлов используется библиотека `mimetypes`, идущая вместе
с компилятором. Для генерации HTML используется библиотека `htmlgen`, так же
входящая в стандартную поставку. В ней определены темплейты `h1`, `ul`, `li`, `a` и т.д.
(поскольку это темплейты, HTML генерируется при компиляции).

Вот, собственно, и всё. Для первого знакомства с Nimrod мне этого хватило, надеюсь,
вам тоже. Если сумею реализовать свои задумки по его использованию --- обязательно
напишу.
